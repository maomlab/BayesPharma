---
title: "Enzyme Kinetics Application Example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Enzyme Kinetics Application Example}
  %\VignetteEncoding{UTF-8}
---
  
```{r set-options, echo=FALSE}

# inspired by https://www.jumpingrivers.com/blog/knitr-default-options-settings-hooks/
knitr::opts_chunk$set(
  cache = TRUE,
  echo = FALSE,
  fig.path = "model_Pnear_distribution_figures/knitr-",
  fig.retina = 2, # Control using dpi
  fig.width = 6,  # generated images
  fig.height = 5, # generated images
  fig.pos = "t",  # pdf mode
  fig.align = "center",
  dpi = if (knitr::is_latex_output()) 72 else 300, 
  out.width = "100%")
#  dev = "svg",
#  dev.args = list(png = list(type = "cairo-png")),
#  optipng = "-o1 -quiet")

# cmdstanr is more up-to-date than rstan and runs a little faster
# but can't expose defined functions for downstream analysis
if(Sys.info()["machine"] == "arm64"){
  #rstan does not currently support apple M1 chips
  stan_backend <- "cmdstanr"
} else {
  stan_backend <- "rstan"
}

```


```{r load-packages}
library(tidyverse)
library(BayesPharma)
library(GeomIndicator)
library(tidybayes)
```


```{r read-data}
data_path <- "~/opt/BayesPharma/inst/extdata/Enzyme Kinetics/Hettiaratchi_2020.xlsx"

data <- tibble::tibble(
  sheet_name = readxl::excel_sheets(data_path)[2:7]) %>%
  dplyr::rowwise() %>%
  dplyr::do({
    sheet_name <- .$sheet_name
    cat("Parsing sheet: '", sheet_name, "' ...\n", sep = "")
    data <- readxl::read_excel(
      path = data_path,
      sheet = sheet_name,
      range = "R2C2:R65C18",
      col_names = TRUE) %>%
      dplyr::mutate(
        substrate_concentration_mg_ml = sheet_name %>%
          stringr::str_extract("^[0-9.]+") %>%
          as.numeric(),
          .before = 1)
  }) %>%
  dplyr::ungroup()
names(data)[seq(4, 16, by = 3)] <- paste0(data[1,2:16] %>% as.character() %>% na.omit(), "_1")
names(data)[seq(5, 17, by = 3)] <- paste0(data[1,2:16] %>% as.character() %>% na.omit(), "_2")
names(data)[seq(6, 18, by = 3)] <- paste0(data[1,2:16] %>% as.character() %>% na.omit(), "_3")
names(data)[2] <- "time_s"
names(data)[3] <- "temperature_C"
data <- data %>%
  dplyr::filter(
    !is.na(time_s),
    time_s != "Time [s]") %>%
  tidyr::pivot_longer(
    cols = -c("substrate_concentration_mg_ml", "time_s", "temperature_C"),
    names_to = "treatment_replica",
    values_to = "product_concentration") %>%
  tidyr::separate(
    col = treatment_replica,
    into = c("treatment", "replica"),
    sep = "_") %>%
  dplyr::mutate(
    replica = as.factor(replica),
    time_s = as.numeric(time_s),
    temperature_C = as.numeric(temperature_C),
    product_concentration = dplyr::case_when(
      product_concentration == "OVER" ~ NA_real_,
      TRUE ~ as.numeric(product_concentration)))

baseline <- data %>%
  dplyr::filter(treatment == "Blank") %>%
  dplyr::group_by(substrate_concentration_mg_ml, time_s) %>%
  dplyr::summarize(
    mean_baseline = mean(product_concentration, na.rm=TRUE),
    .groups = "drop")

data <- data %>%
  dplyr::left_join(
    baseline,
    by = c("substrate_concentration_mg_ml", "time_s")) %>%
  dplyr::mutate(
    normalized_product_concentration = product_concentration - mean_baseline)

```


```{r plot_data}
ggplot2::ggplot(data = data %>% dplyr::filter(treatment != "Blank")) + 
  ggplot2::theme_bw() +
  ggplot2::geom_line(
    mapping = ggplot2::aes(
      x = time_s,
      y = product_concentration * 0.93,
      color = log(substrate_concentration_mg_ml),
      group = paste0(substrate_concentration_mg_ml, "_", replica))) +
  ggplot2::geom_smooth(
    data = data %>%
      dplyr::filter(
        treatment != "Blank",
        time_s <= 200),
    mapping = ggplot2::aes(
      x = time_s,
      y = product_concentration * 0.7,
      group = paste0(substrate_concentration_mg_ml, "_", replica)),
    method = "lm",
    formula = y ~ x,
    color = "orange") +
  ggplot2::facet_wrap(
    facets = dplyr::vars(treatment),
    nrow = 1) +
  ggplot2::theme(legend.position = "bottom") +
  ggplot2::scale_color_continuous(
    "Substrate mg/ml:",
    breaks = log(c(0.5, 1, 2.5, 5, 10, 15)),
    labels = c("0.5", "1", "2.5", "5", "10", "15")) +
  ggplot2::scale_x_continuous("Time (s)") +
  ggplot2::scale_y_continuous(
    "Product mg/ml:",
    breaks = c(0.5, 1, 2.5, 5, 10, 15),
    labels = c("0.5", "1", "2.5", "5", "10", "15")) 

```
```{r simulate-tQ}

devtools::load_all()
data_simulate <- tidyr::expand_grid(
  kcat = 0.0072,
  kM =  0.0448,
  ET = 1,
  ST = c(0.5, 1, 2.5, 5, 10, 15)) %>%
  dplyr::mutate(series_index = dplyr::row_number()) %>%
  dplyr::rowwise() %>%
  dplyr::do({
    data <- .
    time <- seq(0, 1200, by=20)
    data <- data.frame(data,
      time = time,
      P = BayesPharma::tQ_model_generate(
        time = time,
        kcat = data$kcat,
        kM = data$kM,
        ET = data$ET,
        ST = data$ST)[,2])
  })

ggplot2::ggplot(data = data_simulate) + 
  ggplot2::theme_bw() +
  ggplot2::geom_line(
    mapping = ggplot2::aes(
      x = time,
      y = 0.8 + 0.16*P,
      color = log(ST),
      group = ST)) +
  ggplot2::theme(legend.position = "bottom") +
  ggplot2::scale_color_continuous(
    "Substrate mg/ml:",
    breaks = log(c(0.5, 1, 2.5, 5, 10, 15)),
    labels = c("0.5", "1", "2.5", "5", "10", "15")) +
  ggplot2::scale_x_continuous("Time (s)") +
  ggplot2::scale_y_continuous(
    "Product mg/ml:",
    breaks = c(0.5, 1, 2.5, 5, 10, 15),
    labels = c("0.5", "1", "2.5", "5", "10", "15"))



```

```{r model-tQ}

devtools::load_all()

z <- data %>%
  dplyr::filter(treatment %>% stringr::str_detect("^D")) %>%
  dplyr::arrange(
    treatment,
    substrate_concentration_mg_ml,
    replica,
    time_s)

z <- z %>%
  dplyr::left_join(
    z %>%
      dplyr::distinct(
        treatment,
        substrate_concentration_mg_ml,
        replica) %>%
      dplyr::mutate(
        series_index = dplyr::row_number()),
    by = c("treatment", "substrate_concentration_mg_ml", "replica")) %>%
  dplyr::filter(time_s > 0) %>%
  dplyr::filter(!is.na(normalized_product_concentration)) %>%
  dplyr::transmute(
    series_index,
    treatment,
    ET = 1,
    ST = substrate_concentration_mg_ml,
    P = product_concentration,
    time = time_s)





devtools::load_all()
model <- brms::brm(
    data = z,
    formula = brms::brmsformula(
      P ~ baseline + scale * prod,
      brms::nlf(
        prod ~ tQ_multiple(series_index, time, kcat, kM, ET, ST),
        loop = FALSE),
      kcat + kM ~ 0 + treatment,
      baseline + scale ~ 1,
      nl = TRUE),
    prior = c(
      brms::prior(prior = gamma(0.25, 0.01), lb = 0, nlpar = "kcat"),
      brms::prior(prior = gamma(6, 0.01), lb = 0, nlpar = "kM"),
      brms::prior(prior = normal(0, 3), nlpar = "baseline"),
      brms::prior(prior = normal(1, 3), nlpar = "scale")),
    init = function() list(
      kcat = 250,
      kM = 6000,
      baseline = 0,
      scale = 1),
    iter = 4000,
    cores = 4,
    seed = 52L,
    backend = 'cmdstanr',
    stanvars = BayesPharma::tQ_stanvar)


devtools::load_all()               
model <- BayesPharma::tQ_model(
    data = z %>%
      dplyr::filter(treatment == "D14-14"),
    formula = tQ_formula(),
    prior = tQ_prior(
      kcat = brms::prior(prior = gamma(2, 1), lb = 0, nlpar = "kcat"),
      kM = brms::prior(prior = gamma(1000, 1), lb = 0, nlpar = "kM")),
    init = function() list(kcat = 2, kM = 1000),
    iter = 8000,
    backend = 'cmdstanr')

#    control = list(adapt_delta = 0.99))


```


```{r model-multiple-draws, deps=c("model-multiple", "model-multiple-prior")}
model_prior <- model %>%
  brms:::update.brmsfit(sample_prior = "only")

draws_prior <- model_prior %>%
  tidybayes::tidy_draws() %>%
  tidybayes::gather_variables() %>%
  dplyr::filter(.variable %>% stringr::str_detect("b_(kcat|kM)")) %>%
  tidyr::separate(.variable, into = c("class", "parameter", "treatment"), sep = "_") %>%
  dplyr::mutate(treatment = treatment %>% stringr::str_replace("treatment", ""))

draws_posterior <- model %>%
  tidybayes::tidy_draws() %>%
  tidybayes::gather_variables() %>%
  dplyr::filter(.variable %>% stringr::str_detect("b_(kcat|kM)")) %>%
  tidyr::separate(.variable, into = c("class", "parameter", "treatment"), sep = "_") %>%
  dplyr::mutate(treatment = treatment %>% stringr::str_replace("treatment", ""))
```

```{r prior-posterior-multiple-scatter, deps=c("model-multiple-draws")}
draws_prior_pairs <- draws_prior %>%
  tidyr::pivot_wider(
    id_cols = c(".chain", ".iteration", ".draw", "treatment"),
    names_from = "parameter",
    values_from = ".value")

draws_posterior_pairs <- draws_posterior %>%
  tidyr::pivot_wider(
    id_cols = c(".chain", ".iteration", ".draw", "treatment"),
    names_from = "parameter",
    values_from = ".value")

ggplot2::ggplot() +
  ggplot2::theme_bw() +
  # ggplot2::geom_point(
  #   data = draws_prior_pairs,
  #   mapping = ggplot2::aes(
  #     x = kcat,
  #     y = kM),
  #   color = "orange",
  #   size = 0.8,
  #   shape = 16,
  #   alpha = .6) +
    ggplot2::geom_point(
    data = draws_posterior_pairs,
    mapping = ggplot2::aes(
      x = kcat,
      y = kM),
    color = "blue",
    size = .8,
    shape = 16,
    alpha = .3) +
  ggplot2::scale_x_continuous("catalytic constant (kcat)") +
  ggplot2::scale_y_continuous("Michaelis constant (kM)") +
  ggplot2::facet_wrap(facets = dplyr::vars(treatment), nrow = 1, scales = "free")
```



```{r test list-column}


```


```{r generated-code}
write("// generated with brms 2.17.0
functions {
  
vector ode_sQ(
   real time,
   vector state,
   vector params) {
   real E_T = state[1];   // total enzyme
   real S_T = state[2];   // total subtrate
   real P_t = state[3];   // product at time t
   real kcat = params[1];
   real kM = params[2];
   vector[1] dPdt;
   dPdt[1] = kcat * (E_T * (S_T - P_t)) / (kM + S_T + P_t);

   return(dPdt);
}

vector sQ(
  data vector time,
  vector vkcat,
  vector vkM,
  vector vE_T,
  vector vS_T) {

  vector[2] params;
  params[1] = vkcat[1];
  params[2] = vkM[1];
  vector[3] initial_state;
  initial_state[1] = vE_T[1];
  initial_state[2] = vS_T[1];
  initial_state[3] = 0.0;
  real initial_time = 0.0;
  int N = size(time);

  vector[1] P_ode[N] = ode_rk45(
    ode_sQ,                         // function ode
    initial_state,                  // vector initial_state
    initial_time,                   // real initial_time
    to_array_1d(time),              // array[] real times
    params);                        // ..
  
  vector[N] P;
  for(i in 1:N) P[i] = P_ode[i,1];
  return(P);
}

}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K_kcat;  // number of population-level effects
  matrix[N, K_kcat] X_kcat;  // population-level design matrix
  int<lower=1> K_kM;  // number of population-level effects
  matrix[N, K_kM] X_kM;  // population-level design matrix
  // covariate vectors for non-linear functions
  vector[N] C_1;
  vector[N] C_2;
  vector[N] C_3;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
}
parameters {
  vector<lower=0>[K_kcat] b_kcat;  // population-level effects
  vector<lower=0>[K_kM] b_kM;  // population-level effects
  real<lower=0> sigma;  // dispersion parameter
}
transformed parameters {
  real lprior = 0;  // prior contributions to the log posterior
  lprior += gamma_lpdf(b_kcat | 10, 10);
  lprior += gamma_lpdf(b_kM | 10, 10);
  lprior += student_t_lpdf(sigma | 3, 0, 2.5)
    - 1 * student_t_lccdf(0 | 3, 0, 2.5);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] nlp_kcat = X_kcat * b_kcat;
    // initialize linear predictor term
    vector[N] nlp_kM = X_kM * b_kM;
    // initialize non-linear predictor term
    vector[N] mu;
    for (n in 1:N) {
      // compute non-linear predictor values
      mu[n] = sQ(C_1[n] , nlp_kcat[n] , nlp_kM[n] , C_2[n] , C_3[n]);
    }
    target += normal_lpdf(Y | mu, sigma);
  }
  // priors including constants
  target += lprior;
}
generated quantities {
}","/tmp/stan_mm.stan")

model_mm <- cmdstan_model("/tmp/stan_mm.stan")

```


```{r test_data}
library(brms)
library(tidyverse)
library(here)
library(cmdstanr)


# simulated data for exponential decay: c=A0*exp(-k1*time)
set.seed(1)
time <- c(0,1,2,3,4,5,7,9,11)
y_exp <- 100*exp(-0.2*time)  # c0 =100, kr=0.2, exact simulated data
df_sim <- data.frame(time, y_exp)
df_sim <- df_sim %>%
  dplyr::mutate(
   y_obs = y_exp+rnorm(length(time),0,5)) %>%
  dplyr::select(-y_exp)                        # random normal error added to simulated data with mean = 0 and sd = 5
N_t <- length(df_sim$time)                     # number of datapoints

```

```{r test1}

# the next lines of code show the coupling of brms to the old integrators, works without a problem
fo_model <- "
  real[] ode_fo(real t, //time
  real [] y,         // the rates
  real [] theta,     // the parameters
  real [] x_r,       // data constant (not used)
  int[] x_i){        // data constant (not used)
  real dydt[1];      // dimension of ODEs
  dydt[1] = - theta[1] * y[1];                   // first ODE
   return dydt;        // returns a 3-dimensional array     
  }

// this is the function call from brms, integration of ODEs:
real fo_ode(real t, real A0, real k1) {
  real y0[1]; //one initial value
  real theta[1]; //one parameter next to A0
  real y[1,1]; //ODE solution
  y0[1]=A0; //initial values
  theta[1]=k1;

  y=integrate_ode_rk45(ode_fo, y0,0,rep_array(t,1),theta,rep_array(0.0,0), rep_array(1,1), 0.00001,0.00001,100);
// Return relevant values
    return(y[1,1]);
}

"
# t=0 not allowed, will be estimated

df_sim_ode <- df_sim[-1, ]

fo_formula <- brms::bf(
  y_obs ~ fo_ode(time,A0,k1),
  A0 ~ 1,
  k1 ~ 1,
  nl = TRUE)

fo_priors <- c(
  brms::prior(normal(100, 10),nlpar=A0),
  brms::prior(normal(0.2, 0.1), nlpar=k1), 
  brms::prior(cauchy(0, 10), class=sigma))

fo_result1 <- brms::brm(
  data=df_sim_ode,
  family = gaussian,
  formula=fo_formula,
  prior=fo_priors,
  init=0,
  iter=4000,
  chains=4,
  cores=4,
  stanvars = brms::stanvar(
    scode=fo_model,
    block="functions"),
  file="fo_result1")


```


```{r test2}

write("
functions {                  // input to the ode_integrator:
  vector fo(real t,          // time
            vector y,        // state
            vector kr        // parameters (only one in this case, c0 is automatically estimated)
                  ) {      
    vector[1] dydt;
    dydt[1] = -kr[1] * y[1];
    return dydt;
  }
}
data {
  int<lower = 1>   N;
  real             t0;
  real<lower = t0> ts[N];      // each element must be greater than t0
  real             y0_obs;     // the observed initial value
  real             y_obs[N];   //the observed (measured) values excluding the initial value
}
parameters {
  real<lower = 0>      sigma; // experimental sigma
  vector<lower = 0>[1] kr;    // rate constant to be estimated
  vector[1]            y0;    // initial condition to be estimated
}
model {
  vector[1] mu[N] = ode_bdf(fo, y0, t0, ts, kr);  // call to the ode_integrator, result is put in mu
  sigma ~ cauchy(0, 5);                           // prior for sigma
  kr[1] ~ normal(0.2, 0.02);                      // prior for rate constant
  y0 ~ normal(100,10);                            // prior on initial condition
  y0_obs ~ normal(y0[1], sigma);
  for (t in 1:N) {
    y_obs[t] ~ normal(mu[t], sigma);
  }
}    

","/tmp/stan_fo.stan")

# compile the stan model:
fo_model1 <- cmdstan_model("/tmp/stan_fo.stan")
# the data list for Stan:
fo_data <- list(
  N = N_t - 1,                # the first datapoint should not be at time zero because that point is provided by t0 and y0
  t0 = 0,
  ts = df_sim$time[-1],       # omitting the first time datapoint at time zero because that needs to be given for y0 (next line)
  y0_obs = df_sim$y_obs[1],   # the first datapoint is the initial value y0 
  y_obs = df_sim$y_obs[-1]    # the measured data without the starting point
)

# sampling from the compiled model:
fo_fit <- fo_model1$sample(
  data = fo_data,
  seed = 42L,
  refresh = 0,                
  parallel_chains=4 
)


```
```{r test3}
fo_model3 <- "
  vector fo2(real t,                  //time
             vector y,                // the state
             real k1){                // the parameter next to A0
    
             vector[1] dydt;          // dimension of ODE
             dydt[1] = - k1 * y[1];   // ODE
             return dydt;             // returns a 1-dimensional vector     
  }

// function called from brms: integration of ODEs
vector  fo_ode2(
  data vector time,
  vector vA0,
  vector vk1) {
  
  // vector[1] y0 = vA0[1];
  vector[1] y0 = rep_vector(vA0[1], 1);
  int N = size(time);
  vector[1] y_hat_ode[N] = ode_rk45(
    fo2, y0, 0.0, to_array_1d(time), vk1[1]);
  vector[N] y_hat;
  for(i in 1:N) y_hat[i] = y_hat_ode[i,1];
  return(y_hat);
}

"

df_sim_ode <- df_sim[-1,] #remove the first datapoint at t0

fo_formula <- brms::bf(y_obs~fo_ode2(time,A0,k1),
                  A0~1,
                  k1~1,
                  nl=TRUE, loop=FALSE)

fo_priors <- c(brms::prior(normal(100,10),nlpar=A0),
                brms::prior(normal(0.2,0.1), nlpar=k1), 
                brms::prior(cauchy(0,10), class=sigma))

fo_result2 <- brms::brm(
  data = df_sim_ode,
  family = gaussian,
  formula=fo_formula,
  prior=fo_priors,
  init=0,
  iter=4000,
  chains=4,
  cores=4,
  stanvars = brms::stanvar(
    scode=fo_model3,
    block="functions"),
  backend="cmdstanr",
  file="fo_result3")
```

